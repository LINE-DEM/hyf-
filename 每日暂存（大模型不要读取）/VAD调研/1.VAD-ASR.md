# VAD ASR Controller API层实现计划

## 概述

创建一个VAD API层 `VADASRController`，封装现有的 `SileroVADManager` 和 `XunFeiManager`，实现VAD驱动的自动ASR控制。

## 需求确认

- **ASR启动**: VAD检测到人声 → 自动开启ASR（无需唤醒词）
- **打断功能**: 同时支持打断TTS播放和打断ASR识别
- **尾部静音**: 可配置延迟时间
- **状态机**: 完整状态机 (Idle → Listening → Processing → Speaking)

---

## 文件结构

```
Assets/c#/System/VAD/
├── VADASRController.cs      # 主控制器（新建）
├── VADASRState.cs           # 状态枚举和类型（新建）
├── VADASRConfig.cs          # 配置类（新建）
├── MainThreadDispatcher.cs  # 主线程调度器（新建）
└── SileroVADManager.cs      # 现有VAD（不修改）
```

---

## 实现步骤

### 步骤1: 创建状态枚举和类型定义

**文件**: `Assets/c#/System/VAD/VADASRState.cs`

```csharp
public enum VADASRState
{
    Idle,        // 空闲，等待VAD检测人声
    Listening,   // 监听中，ASR正在进行
    Processing,  // 处理中，等待AI响应
    Speaking,    // 说话中，TTS播放
    Paused,      // 暂停
    Error        // 错误
}

public enum InterruptType
{
    TTSInterrupt,    // 用户打断TTS
    ASRCancel,       // 用户取消ASR
    SystemInterrupt, // 系统打断
    Timeout          // 超时
}

public class VADASRError
{
    public VADASRErrorCode Code { get; set; }
    public string Message { get; set; }
    public Exception Exception { get; set; }
}

public enum VADASRErrorCode
{
    WebSocketConnectionFailed,
    WebSocketDisconnected,
    ASRSendFailed,
    ASRReceiveFailed,
    MicrophoneError,
    VADError,
    Timeout,
    Unknown
}
```

### 步骤2: 创建配置类

**文件**: `Assets/c#/System/VAD/VADASRConfig.cs`

```csharp
using System;
using UnityEngine;

[Serializable]
public class VADASRConfig
{
    [Header("VAD配置")]
    [Range(0f, 1f)]
    public float vadThreshold = 0.5f;

    [Header("尾部静音配置")]
    [Tooltip("人声结束后等待发送结束包的延迟时间（毫秒）")]
    [Range(100, 5000)]
    public int tailSilenceDelayMs = 800;

    [Tooltip("最短有效语音时长（毫秒），低于此时长的语音将被忽略")]
    [Range(100, 2000)]
    public int minVoiceDurationMs = 300;

    [Tooltip("最大录音时长（秒）")]
    [Range(10, 120)]
    public float maxRecordingDuration = 60f;

    [Header("打断配置")]
    public bool enableTTSInterrupt = true;
    public bool enableASRAutoRestart = true;

    [Header("音频配置")]
    public int sampleRate = 16000;
    public int frameSamples = 640; // 40ms @ 16kHz

    public static VADASRConfig Default => new VADASRConfig();
}
```

### 步骤3: 创建主线程调度器

**文件**: `Assets/c#/System/VAD/MainThreadDispatcher.cs`

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;

public class MainThreadDispatcher : MonoBehaviour
{
    private static MainThreadDispatcher _instance;
    private static readonly Queue<Action> _pendingActions = new Queue<Action>();
    private static readonly object _lock = new object();

    public static MainThreadDispatcher Instance
    {
        get
        {
            if (_instance == null)
            {
                var go = new GameObject("MainThreadDispatcher");
                _instance = go.AddComponent<MainThreadDispatcher>();
                DontDestroyOnLoad(go);
            }
            return _instance;
        }
    }

    public static void Enqueue(Action action)
    {
        if (action == null) return;
        lock (_lock)
        {
            _pendingActions.Enqueue(action);
        }
    }

    void Update()
    {
        lock (_lock)
        {
            while (_pendingActions.Count > 0)
            {
                try
                {
                    _pendingActions.Dequeue()?.Invoke();
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[MainThreadDispatcher] Error: {ex.Message}");
                }
            }
        }
    }
}
```

### 步骤4: 创建主控制器

**文件**: `Assets/c#/System/VAD/VADASRController.cs`

继承 `MonoSingleton<VADASRController>`

#### 核心功能模块：

**1) 状态管理**
```csharp
private VADASRState _currentState;
private readonly object _stateLock = new object();

private bool TransitionTo(VADASRState newState, string reason);
private bool IsValidTransition(VADASRState from, VADASRState to);
```

**2) VAD事件处理**
```csharp
private void HandleVADStateChanged(bool isVoiceActive)
{
    if (isVoiceActive)
        HandleVoiceStart();  // Idle→Listening 或 Speaking→Listening(打断)
    else
        HandleVoiceEnd();    // 启动尾部静音计时
}
```

**3) 尾部静音处理**
```csharp
private IEnumerator TailSilenceTimerCoroutine()
{
    yield return new WaitForSeconds(tailSilenceDelayMs / 1000f);
    if (!_vadManager.IsVoiceActive())
    {
        await SendASREndPacket();
        TransitionTo(VADASRState.Processing);
    }
}
```

**4) ASR会话管理（解决并发问题）**
```csharp
private readonly SemaphoreSlim _sendSemaphore = new SemaphoreSlim(1, 1);

private async Task SendASRFirstPacket(byte[] audioData);   // status=0
private async Task SendASRMiddlePacket(byte[] audioData);  // status=1
private async Task SendASREndPacket();                     // status=2
```

**5) 打断机制**
```csharp
public void InterruptTTS();   // 停止TTS播放
public void CancelASR();      // 取消当前ASR
public void ForceStop();      // 强制停止所有
```

**6) 公共接口**
```csharp
public void SetVADThreshold(float threshold);
public void SetTailSilenceDelay(int delayMs);
public void ManualStartASR();  // 手动触发（按钮模式）
public void ManualEndASR();    // 手动结束
```

---

## 状态转换图

```
         ┌──────────────────────────────────────────┐
         │                                           │
         ▼                                           │
    ┌────────┐   VAD人声   ┌───────────┐   ASR完成  ┌────────────┐
    │  Idle  │ ──────────→ │ Listening │ ────────→ │ Processing │
    └────────┘             └───────────┘           └────────────┘
         ▲                      │                       │
         │                      │ 取消/超时              │ TTS开始
         │                      ▼                       ▼
         │                 返回Idle              ┌──────────┐
         │                                       │ Speaking │
         │                                       └──────────┘
         │                                            │
         └────────────────────────────────────────────┘
                          TTS完成/被打断
```

---

## 事件定义

| 事件                       | 参数                   | 用途      |
| ------------------------ | -------------------- | ------- |
| `OnStateChanged`         | (oldState, newState) | 状态变化通知  |
| `OnPartialResult`        | string               | ASR中间结果 |
| `OnFinalResult`          | string               | ASR最终结果 |
| `OnVoiceActivityChanged` | bool                 | VAD状态变化 |
| `OnInterrupt`            | InterruptType        | 打断事件    |
| `OnError`                | VADASRError          | 错误事件    |

---

## 与现有组件集成

### 订阅VAD事件
```csharp
_vadManager.OnVoiceActivityChanged += HandleVADStateChanged;
```

### 订阅MessageCenter事件
```csharp
MessageCenter.Subscribe<string>("ASR_Recv", HandleASRReceived);
MessageCenter.Subscribe<string>("TTS_Started", HandleTTSStarted);
MessageCenter.Subscribe<string>("TTS_Finished", HandleTTSFinished);
```

### 调用现有组件
```csharp
// ASR发送
await XunFeiManager.Instance.STTSendMessageNew(audioData, status);

// TTS打断
AudioMgr.Instance.StopAudio();
```

---

## 关键实现细节

### 1. 并发安全
使用 `SemaphoreSlim` 防止WebSocket发送冲突：
```csharp
await _sendSemaphore.WaitAsync();
try { await SendPacket(); }
finally { _sendSemaphore.Release(); }
```

### 2. 会话管理
每个ASR会话有唯一SessionId和CancellationToken，确保旧会话不干扰新会话。

```csharp
private class ASRSession
{
    public string SessionId { get; set; }
    public bool IsConnected { get; set; }
    public bool HasSentFirstPacket { get; set; }
    public bool HasSentEndPacket { get; set; }
    public bool IsReceiving { get; set; }
    public CancellationTokenSource CancellationToken { get; set; }
    public DateTime StartTime { get; set; }
}
```

### 3. 线程安全
VAD在后台线程运行，通过MainThreadDispatcher调度到Unity主线程。

### 4. 状态转换验证
```csharp
private bool IsValidTransition(VADASRState from, VADASRState to)
{
    // 允许任何状态转换到Error和Paused
    if (to == VADASRState.Error || to == VADASRState.Paused)
        return true;

    switch (from)
    {
        case VADASRState.Idle:
            return to == VADASRState.Listening;
        case VADASRState.Listening:
            return to == VADASRState.Processing || to == VADASRState.Idle;
        case VADASRState.Processing:
            return to == VADASRState.Speaking || to == VADASRState.Idle || to == VADASRState.Listening;
        case VADASRState.Speaking:
            return to == VADASRState.Idle || to == VADASRState.Listening;
        case VADASRState.Error:
            return to == VADASRState.Idle;
        default:
            return false;
    }
}
```

---

## 关键文件（需阅读）

- `Assets/c#/System/VAD/SileroVADManager.cs` - VAD事件回调
- `Assets/AIChatTookit/Speech/StrmingBranch/XunFeiManager.cs` - ASR发送方法
- `Assets/c#/Audio/AudioMgr.cs` - TTS停止方法
- `Assets/c#/FrameWork/MessageCenter.cs` - 事件总线API
- `Assets/c#/FrameWork/MonoSingleton.cs` - 单例基类

---

## 验证方案

1. **VAD→ASR自动启动**
   - 说话，观察是否自动开启ASR
   - 检查日志: `[VADASRController] State: Idle -> Listening`

2. **尾部静音检测**
   - 停止说话，等待配置的延迟时间
   - 检查ASR结束包是否发送

3. **TTS打断**
   - TTS播放时开始说话
   - 检查TTS是否停止，ASR是否启动

4. **ASR取消**
   - 调用 `VADASRController.Instance.CancelASR()`
   - 检查状态是否返回Idle

5. **并发安全**
   - 快速连续说话/停止
   - 检查是否有WebSocket并发错误

---

## 完整代码框架

### VADASRController.cs 主要结构

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using unity_chan_;

public class VADASRController : MonoSingleton<VADASRController>
{
    #region 配置参数
    [Header("VAD配置")]
    [SerializeField] private float vadThreshold = 0.5f;

    [Header("尾部静音配置")]
    [SerializeField] private int tailSilenceDelayMs = 800;
    [SerializeField] private int minVoiceDurationMs = 300;
    [SerializeField] private float maxRecordingDuration = 60f;

    [Header("打断配置")]
    [SerializeField] private bool enableTTSInterrupt = true;
    [SerializeField] private bool enableASRAutoRestart = true;

    [Header("调试")]
    [SerializeField] private bool showDebugLogs = true;
    #endregion

    #region 组件引用
    private SileroVADManager _vadManager;
    private XunFeiManager _asrManager;
    private AudioMgr _audioMgr;
    #endregion

    #region 状态管理
    private VADASRState _currentState = VADASRState.Idle;
    private readonly object _stateLock = new object();
    private ASRSession _currentSession;
    private readonly SemaphoreSlim _sendSemaphore = new SemaphoreSlim(1, 1);

    private Coroutine _tailSilenceCoroutine;
    private Coroutine _recordingTimeoutCoroutine;
    private float _voiceStartTime;
    private float _lastVoiceEndTime;
    #endregion

    #region 事件定义
    public event Action<VADASRState, VADASRState> OnStateChanged;
    public event Action<string> OnPartialResult;
    public event Action<string> OnFinalResult;
    public event Action<VADASRError> OnError;
    public event Action<bool> OnVoiceActivityChanged;
    public event Action<InterruptType> OnInterrupt;
    #endregion

    #region 公共属性
    public VADASRState CurrentState => _currentState;
    public bool IsListening => _currentState == VADASRState.Listening;
    public bool IsProcessing => _currentState == VADASRState.Processing;
    public bool IsSpeaking => _currentState == VADASRState.Speaking;
    #endregion

    #region 生命周期
    protected override void Awake()
    {
        base.Awake();
        InitializeComponents();
    }

    private void Start()
    {
        SubscribeToEvents();
    }

    private void OnDestroy()
    {
        UnsubscribeFromEvents();
        CleanupResources();
    }
    #endregion

    #region 初始化
    private void InitializeComponents()
    {
        _vadManager = FindObjectOfType<SileroVADManager>();
        _asrManager = XunFeiManager.Instance;
        _audioMgr = AudioMgr.Instance;

        if (_vadManager != null)
            _vadManager.SetThreshold(vadThreshold);
    }

    private void SubscribeToEvents()
    {
        if (_vadManager != null)
        {
            _vadManager.OnVoiceActivityChanged += HandleVADStateChanged;
        }

        MessageCenter.Subscribe<string>("ASR_Recv", HandleASRReceived);
        MessageCenter.Subscribe<string>("TTS_Started", HandleTTSStarted);
        MessageCenter.Subscribe<string>("TTS_Finished", HandleTTSFinished);
    }

    private void UnsubscribeFromEvents()
    {
        if (_vadManager != null)
        {
            _vadManager.OnVoiceActivityChanged -= HandleVADStateChanged;
        }

        MessageCenter.Unsubscribe<string>("ASR_Recv", HandleASRReceived);
        MessageCenter.Unsubscribe<string>("TTS_Started", HandleTTSStarted);
        MessageCenter.Unsubscribe<string>("TTS_Finished", HandleTTSFinished);
    }
    #endregion

    #region VAD处理
    private void HandleVADStateChanged(bool isVoiceActive)
    {
        if (showDebugLogs)
            Debug.Log($"[VADASRController] VAD: {(isVoiceActive ? "Voice" : "Silence")}");

        MainThreadDispatcher.Enqueue(() =>
        {
            OnVoiceActivityChanged?.Invoke(isVoiceActive);

            if (isVoiceActive)
                HandleVoiceStart();
            else
                HandleVoiceEnd();
        });
    }

    private void HandleVoiceStart()
    {
        _voiceStartTime = Time.time;

        switch (_currentState)
        {
            case VADASRState.Idle:
                TransitionTo(VADASRState.Listening, "VAD detected voice");
                break;

            case VADASRState.Listening:
                CancelTailSilenceTimer();
                break;

            case VADASRState.Speaking:
                if (enableTTSInterrupt)
                {
                    OnInterrupt?.Invoke(InterruptType.TTSInterrupt);
                    InterruptTTS();
                    TransitionTo(VADASRState.Listening, "User interrupted TTS");
                }
                break;
        }
    }

    private void HandleVoiceEnd()
    {
        _lastVoiceEndTime = Time.time;

        if (_currentState == VADASRState.Listening)
        {
            float voiceDuration = _lastVoiceEndTime - _voiceStartTime;
            if (voiceDuration * 1000 < minVoiceDurationMs)
            {
                if (showDebugLogs)
                    Debug.Log($"[VADASRController] Voice too short: {voiceDuration * 1000}ms");
                return;
            }

            StartTailSilenceTimer();
        }
    }
    #endregion

    #region 尾部静音
    private void StartTailSilenceTimer()
    {
        CancelTailSilenceTimer();
        _tailSilenceCoroutine = StartCoroutine(TailSilenceTimerCoroutine());
    }

    private void CancelTailSilenceTimer()
    {
        if (_tailSilenceCoroutine != null)
        {
            StopCoroutine(_tailSilenceCoroutine);
            _tailSilenceCoroutine = null;
        }
    }

    private IEnumerator TailSilenceTimerCoroutine()
    {
        yield return new WaitForSeconds(tailSilenceDelayMs / 1000f);

        if (_currentState == VADASRState.Listening &&
            _vadManager != null && !_vadManager.IsVoiceActive())
        {
            if (showDebugLogs)
                Debug.Log("[VADASRController] Tail silence timeout - ending ASR");

            // 发送结束包
            _ = SendASREndPacket();

            TransitionTo(VADASRState.Processing, "Tail silence timeout");
        }
    }
    #endregion

    #region 状态管理
    private bool TransitionTo(VADASRState newState, string reason)
    {
        lock (_stateLock)
        {
            VADASRState oldState = _currentState;

            if (!IsValidTransition(oldState, newState))
            {
                if (showDebugLogs)
                    Debug.LogWarning($"[VADASRController] Invalid: {oldState} -> {newState}");
                return false;
            }

            _currentState = newState;

            if (showDebugLogs)
                Debug.Log($"[VADASRController] State: {oldState} -> {newState} ({reason})");

            OnStateTransition(oldState, newState);
            OnStateChanged?.Invoke(oldState, newState);

            return true;
        }
    }

    private void OnStateTransition(VADASRState from, VADASRState to)
    {
        // 退出旧状态
        if (from == VADASRState.Listening)
        {
            CancelTailSilenceTimer();
        }

        // 进入新状态
        switch (to)
        {
            case VADASRState.Listening:
                StartASRSession();
                break;
            case VADASRState.Idle:
                ResetSessionState();
                break;
        }
    }
    #endregion

    #region ASR会话
    private async void StartASRSession()
    {
        await CancelCurrentSession();

        _currentSession = new ASRSession();

        if (showDebugLogs)
            Debug.Log($"[VADASRController] ASR Session: {_currentSession.SessionId}");

        // 连接并开始发送音频
        // ... 实现连接逻辑
    }

    private async Task CancelCurrentSession()
    {
        if (_currentSession != null)
        {
            _currentSession.CancellationToken?.Cancel();

            if (_currentSession.IsConnected && !_currentSession.HasSentEndPacket)
            {
                try { await SendASREndPacket(); }
                catch { }
            }

            _currentSession.CancellationToken?.Dispose();
            _currentSession = null;
        }
    }

    private async Task SendASREndPacket()
    {
        await _sendSemaphore.WaitAsync();
        try
        {
            if (_currentSession != null && !_currentSession.HasSentEndPacket)
            {
                await XunFeiManager.Instance.STTSendMessageNew(Array.Empty<byte>(), 2);
                _currentSession.HasSentEndPacket = true;
            }
        }
        finally
        {
            _sendSemaphore.Release();
        }
    }
    #endregion

    #region 打断
    public void InterruptTTS()
    {
        if (_audioMgr != null)
        {
            _audioMgr.StopAudio();
        }
        MessageCenter.Publish("TTS_Interrupted", "User interrupt");
    }

    public async void CancelASR()
    {
        if (_currentState != VADASRState.Listening) return;

        CancelTailSilenceTimer();
        await CancelCurrentSession();

        OnInterrupt?.Invoke(InterruptType.ASRCancel);
        TransitionTo(VADASRState.Idle, "ASR cancelled");
    }

    public async void ForceStop()
    {
        StopAllCoroutines();
        _audioMgr?.StopAudio();
        await CancelCurrentSession();
        TransitionTo(VADASRState.Idle, "Force stopped");
    }
    #endregion

    #region 公共接口
    public void SetVADThreshold(float threshold)
    {
        vadThreshold = Mathf.Clamp01(threshold);
        _vadManager?.SetThreshold(vadThreshold);
    }

    public void SetTailSilenceDelay(int delayMs)
    {
        tailSilenceDelayMs = Mathf.Clamp(delayMs, 100, 5000);
    }
    #endregion

    #region 事件处理
    private void HandleASRReceived(string msg) { }
    private void HandleTTSStarted(string msg)
    {
        if (_currentState == VADASRState.Processing)
            TransitionTo(VADASRState.Speaking, "TTS started");
    }
    private void HandleTTSFinished(string msg)
    {
        if (_currentState == VADASRState.Speaking)
            TransitionTo(VADASRState.Idle, "TTS finished");
    }
    private void ResetSessionState() { _currentSession = null; }
    private void CleanupResources()
    {
        _sendSemaphore?.Dispose();
    }
    #endregion
}

internal class ASRSession
{
    public string SessionId { get; set; } = Guid.NewGuid().ToString("N").Substring(0, 8);
    public bool IsConnected { get; set; }
    public bool HasSentFirstPacket { get; set; }
    public bool HasSentEndPacket { get; set; }
    public CancellationTokenSource CancellationToken { get; set; } = new CancellationTokenSource();
}
```

---

## 使用示例

```csharp
// 在其他脚本中使用
void Start()
{
    var controller = VADASRController.Instance;

    // 订阅事件
    controller.OnStateChanged += (oldState, newState) =>
    {
        Debug.Log($"状态变化: {oldState} -> {newState}");
    };

    controller.OnFinalResult += (text) =>
    {
        Debug.Log($"识别结果: {text}");
    };

    controller.OnInterrupt += (type) =>
    {
        Debug.Log($"打断类型: {type}");
    };

    // 配置参数
    controller.SetVADThreshold(0.5f);
    controller.SetTailSilenceDelay(800);
}

// 手动打断
void OnUserPressStop()
{
    VADASRController.Instance.CancelASR();
}

// 强制停止所有
void OnExit()
{
    VADASRController.Instance.ForceStop();
}
```

---

报告生成时间: 2026-01-16
