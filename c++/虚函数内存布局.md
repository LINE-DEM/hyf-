# C++ 虚函数与继承机制：底层内存布局与陷阱全景

本文档通过代码实例、内存布局分析及汇编伪代码，深入剖析 C++ 虚函数机制在单继承和多重继承场景下的底层实现原理。

**编译环境说明：**

- 编译命令：`g++ -std=c++17 -g -O0 -fdump-class-hierarchy test.cpp`
    
- 查看内存布局：`clang++ -Xclang -fdump-record-layouts -c test.cpp`
    
- 查看汇编：`g++ -S -masm=intel test.cpp`
    

---

## 1. 单继承 + 虚函数：最简单的 vtable 结构

### 1.1 代码定义

C++

```
namespace Case1_SingleInheritance {
    
class Base {
public:
    int base_data = 10;
    virtual void foo() { std::cout << "Base::foo()\n"; }
    virtual void bar() { std::cout << "Base::bar()\n"; }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int derived_data = 20;
    void foo() override { std::cout << "Derived::foo()\n"; }
    // bar() 未重写，继承 Base::bar()
};

} // namespace Case1_SingleInheritance
```

### 1.2 内存布局（64位系统）

`Derived` 对象在内存中只包含一个 `vptr`，该指针指向合并后的虚函数表。

对象内存结构：

| Offset | Member | Size | Description |

| :--- | :--- | :--- | :--- |

| +0 | vptr | 8 bytes | 指向 Derived::vtable |

| +8 | base_data | 4 bytes | 父类数据成员 |

| +12 | derived_data | 4 bytes | 子类数据成员 |

| Total | | 16 bytes | |

**VTable 结构 (vtable for Derived):**

- `[0]` -> `typeinfo for Derived` (RTTI)
    
- `[1]` -> `Derived::~Derived()` (析构函数)
    
- `[2]` -> `Derived::foo()` (**重写**，指向子类实现)
    
- `[3]` -> `Base::bar()` (**继承**，指向父类实现)
    

### 1.3 核心测试逻辑

C++

```
void test() {
    Derived d;
    Base* pb = &d;
    
    // 1. 静态绑定（Static Binding）
    // 编译器在编译期直接确定函数地址
    d.foo();  // call Derived::foo() 直接调用
    
    // 2. 动态绑定（Dynamic Binding）
    // 运行期查表，产生性能开销
    pb->foo(); 
    /* 汇编伪代码（Intel 语法）：
       mov rax, QWORD PTR [rdi]         ; 取 vptr
       mov rax, QWORD PTR [rax + 16]    ; vtable[2] (foo 的偏移)
       call rax                         ; 间接调用
    */
    
    // 3. 强制静态绑定
    // 使用作用域解析符，跳过 vtable 查找
    pb->Base::foo(); // call Base::foo() 直接调用
}
```

---

## 2. 多重继承：多个 vptr 的对象切片问题

多重继承下，对象内部会包含**多个虚表指针（vptr）**，这导致了指针转换时的地址偏移（Thunk Adjustment）问题。

### 2.1 代码定义

C++

```
namespace Case2_MultipleInheritance {

class Base1 {
public:
    int b1_data = 1;
    virtual void f1() { std::cout << "Base1::f1()\n"; }
    virtual ~Base1() = default;
};

class Base2 {
public:
    int b2_data = 2;
    virtual void f2() { std::cout << "Base2::f2()\n"; }
    virtual ~Base2() = default;
};

class Derived : public Base1, public Base2 {
public:
    int d_data = 3;
    void f1() override { std::cout << "Derived::f1()\n"; }
    void f2() override { std::cout << "Derived::f2()\n"; }
};

} // namespace Case2_MultipleInheritance
```

### 2.2 内存布局（关键：双 vptr）

`Derived` 对象实际上是由两个“子对象”拼接而成，每个子对象都有自己的 `vptr`。

对象内存结构：

| Offset | Member | Size | Description |

| :--- | :--- | :--- | :--- |

| +0 | vptr1 | 8 bytes | 指向 vtable_for_Base1 (主表) |

| +8 | b1_data | 4 bytes | Base1 数据 |

| +12 | padding | 4 bytes | 内存对齐 |

| +16 | vptr2 | 8 bytes | 指向 vtable_for_Base2 (次表) |

| +24 | b2_data | 4 bytes | Base2 数据 |

| +28 | d_data | 4 bytes | Derived 数据 |

| Total | | 32 bytes | |

### 2.3 指针偏移与 Thunk 技术

当通过第二个父类指针调用子类重写的函数时，编译器必须调整 `this` 指针，使其指回对象的起始位置。

C++

```
void test() {
    Derived d;
    
    // 指针转换的内存调整
    Base1* p1 = &d;  // p1 == &d + 0
    Base2* p2 = &d;  // p2 == &d + 16  <- 关键！指针值改变，指向 Base2 子对象部分
    
    // 汇编层面的 Thunk 调整
    // 当调用 p2->f2() 时，需要将 this 指针从 +16 处减去 16，回到 +0 处
    /* 汇编伪代码：
       ; 调用前：this 指向 Base2 子对象（+16）
       sub rdi, 16              ; 调整 this 指针到 Derived 起始
       mov rax, [rdi]           ; 取 vptr1
       call [rax + offset]      ; 调用 Derived::f2()
    */
    p2->f2();
    
    // 【危险操作】reinterpret_cast
    // 强制转换只改变类型，不改变地址值。
    // 这里 p2 指向 +16，但被强转为 Base1*（期望指向 +0）。
    // 如果此时调用 wrong->f1()，程序会尝试在 +16 处寻找 vtable_for_Base1，导致崩溃。
    Base1* wrong = reinterpret_cast<Base1*>(p2); 
}
```