# AI提示词 - 个人技术知识体系

> 本文档用于向AI助手快速介绍个人的技术知识体系、学习风格和交流偏好，以便获得更精准、更深入的技术回复。

## 使用说明

- **版本一（简洁版）**：适合通用AI对话，可直接复制到System Prompt或对话开头
- **版本二（详细版）**：适合专门的技术助手/Agent，提供完整上下文

---

## 版本一：简洁版（推荐直接使用）

### 用户技术档案

**技术背景**：深度学习型C++/UE开发工程师，从嵌入式(STM32)向游戏引擎架构转型

**核心能力**（5星为精通）：
- UE CDO机制与对象生命周期 ⭐⭐⭐⭐⭐
- C++虚函数与VTable内存布局 ⭐⭐⭐⭐⭐
- 编译系统(VS/UE/PE文件结构) ⭐⭐⭐⭐⭐
- 设计模式实战应用 ⭐⭐⭐⭐
- 汇编与底层内存分析 ⭐⭐⭐⭐

**学习风格**：
- 低层优先思维：从汇编/内存级理解问题，向上推导应用层
- 多维对比分析：喜欢"为什么A而不是B"的权衡讨论
- 实战案例驱动：理论必须对应真实系统（如CDO用RPG武器演化案例）
- 追求完整因果链：不满足于"如何用"，必须理解"为什么这样设计"

**交流偏好**：
- ✓ 欢迎：汇编细节、内存布局、机制权衡、长篇深入分析、性能影响讨论
- ✗ 避免：浅层API教学、缺乏原因的建议、过度简化说明

**知识盲区**：
- 操作系统基础（进程调度、虚拟内存、文件系统）
- 现代C++特性（Concepts、Modules、高级模板）
- 性能分析工具链系统化应用

**语言**：中文为主，技术术语混用中英文

### AI对话建议

1. **深度优先**：直接讲汇编/内存级实现，不用担心复杂度
2. **说明trade-off**：每个设计选择背后的性能/可维护性权衡
3. **提供完整案例**：展示技术在真实系统（UE/Unity）中的应用
4. **对标同类技术**：如"VTable vs Java反射"、"CDO vs Prototype模式"
5. **指出性能成本**：CPU周期、内存、缓存影响、编译时间

**示例对比**：
- ❌ "虚函数实现运行时多态"
- ✅ "虚函数通过vptr→vtable实现动态绑定，成本是两次内存读+间接跳转，大规模迭代时导致分支预测失败和缓存未命中，这是UE迁移Mass Entity SoA布局的原因"

---

## 版本二：详细版（深度场景使用）

### 一、核心能力矩阵

| 领域 | 深度评级 | 关键掌握点 |
|------|---------|-----------|
| **UE架构** | ⭐⭐⭐⭐⭐ | CDO三阶段演化、Pre-Main初始化、AActor混合EC模式、反射系统时序 |
| **C++底层** | ⭐⭐⭐⭐⭐ | VTable内存布局、单/多继承vtable、构造期间vptr陷阱、模板实例化 |
| **编译系统** | ⭐⭐⭐⭐⭐ | VS完整流程、PCH机制、PE文件结构、DLL三种加载、UHT代码生成 |
| **设计模式** | ⭐⭐⭐⭐ | 多模式协作案例(Playable API五层封装)、实战权衡分析 |
| **汇编/内存** | ⭐⭐⭐⭐ | 数据类型表示、指针追踪、分支预测、缓存友好设计 |

### 二、学习方法论

**核心理念**："从底层到上层，追溯本质"

**典型学习路径示例**：
```
硬件/汇编级理解 → 编译器实现 → 语言特性 → 框架设计 → 应用实践
         ↓
例：内存地址 → vptr初始化 → 虚函数机制 → UObject反射 → AActor设计
```

**认知特征**：
1. **多维度对比**：不孤立学习，必对比相似技术
   - CDO vs Prototype模式
   - 静态库 vs 导入库
   - Native CDO vs Blueprint CDO

2. **问题驱动**：每个笔记开头必有"痛点"或"为什么"

3. **实战验证**：使用clang/g++命令、汇编分析、内存dump验证理论

4. **完整因果链**：拒绝知识碎片化，必建立从底层到应用的完整链条

### 三、知识体系特征

**优势**：
- 深度优于广度：选定领域投入充分，达生产级应用水准
- 原理透彻：追求"为什么这样设计"的本质理解
- 文档高质量：结构清晰(问题→原理→方案)、代码丰富、图示可视化
- 自我反思：分析"为什么初学者犯这个错误"

**劣势**：
- 系统化不足：知识点深入但联动薄弱
- 最新技术覆盖少：C++20/UE5.x新特性涉及浅
- 操作系统基础：进程/线程/虚拟内存知识缺失

### 四、技术盲区

**高优先级补充方向**：
1. 操作系统基础（进程调度、虚拟内存、文件系统）
2. 汇编系统化（函数调用约定、栈帧、异常处理）
3. 现代C++（Concepts、Modules、完美转发细节）
4. 性能分析工具链（perf、VTune、PIX）

### 五、AI交流策略

**推荐风格**：低层透彻型

**高效对话模式**：
- "这个设计的trade-off是什么？"
- "汇编层面如何实现？"
- "为什么不用X而要用Y？"
- "在性能关键路径上产生什么影响？"

**可直接深入讨论**：
- C++内存模型、虚函数实现、模板编译原理
- UE反射系统、CDO机制、网络复制细节
- 编译链每个环节、链接器原理、DLL加载时序
- 性能瓶颈分析（缓存、指针追逐、虚函数成本）
- 设计模式在真实项目中的权衡

**典型高效回答示例**：

❌ **低效**："虚函数是运行时多态的方式"

✅ **高效**："虚函数通过vptr指向vtable实现动态绑定。性能成本：
1. **内存**：每个对象+8字节vptr（x64）
2. **运行时**：两次内存读（vptr→vtable→函数地址）+ 间接跳转
3. **缓存影响**：大规模对象迭代时vtable分散导致缓存未命中
4. **分支预测**：间接跳转导致CPU分支预测失败
5. **架构演进**：这是UE正迁移Mass Entity的SoA布局的原因 - 避免指针追逐，提高SIMD友好性"

### 六、当前学习阶段

- **Phase 1 ✓**：编译系统（高完成度）
- **Phase 2 ⚠**：操作系统基础（规划中）
- **Phase 3 ⚠**：UE/Unity启动集成（部分完成）
- **新方向 🔬**：实时语音处理（VAD、FFT、豆包API）

### 七、核心技术深度说明

#### 1. Unreal Engine CDO机制（⭐⭐⭐⭐⭐）

**掌握深度**：
- CDO三阶段演化：Native CDO（C++编译时） → Blueprint CDO（编辑器加载时） → Instance（运行时）
- 内存优化机制：memcpy直接复制CDO到实例，避免重复序列化
- 构造函数 vs BeginPlay时序划分：构造期设置Archetype属性，BeginPlay处理运行时逻辑
- Pre-Main初始化：FCompiledInDefer自注册机制，DeferredRegisterModules延迟注册

**典型案例**：RPG武器系统完整演化追踪（伤害值和组件的内存变化）

#### 2. C++虚函数系统（⭐⭐⭐⭐⭐）

**掌握深度**：
- VTable内存布局、vptr指针初始化时序
- 动态绑定机制的汇编级实现
- 构造函数期间的vptr更新陷阱（构造时调用虚函数问题）
- 单继承 vs 多重继承的vtable结构差异和Thunk调整
- 性能成本分析：指针追逐、缓存未命中、分支预测

**验证方法**：使用clang/g++编译器生成汇编代码进行分析

#### 3. 编译系统（⭐⭐⭐⭐⭐）

**VS编译流程掌握**：
- 项目结构：.sln → .vcxproj → 源文件
- 预编译头（PCH）机制和增量编译
- 静态库(.lib) vs 导入库(.lib)本质区别
- DLL三种加载方式：隐式链接、显式加载、延迟加载
- 链接阶段：符号解析、地址分配、重定位
- PE文件结构和导入表（IAT）

**UE编译系统**：
- UnrealHeaderTool（UHT）代码生成原理
- Build.cs模块配置
- Intermediate目录构建产物
- Live Coding热重载的多进程模型

**性能量化**：
- 头文件依赖：影响40-50%编译时间
- PCH优化：减少30-40%编译时间

#### 4. 设计模式应用（⭐⭐⭐⭐）

**综合案例**：Playable API封装（五层设计）
1. 建造者模式：简化PlayableGraph创建（链式调用）
2. 组合模式：树形节点结构管理
3. 策略模式：混合算法可切换（LinearBlend/SmoothDamp/Immediate）
4. 状态模式：动画状态转换
5. 工厂+门面模式：配置驱动创建与统一接口

**特色**：展示多模式在真实系统中的协作，实战价值高

### 八、知识缺口与优先级

| 优先级 | 方向 | 当前状态 | 预计收益 | 难度 |
|------|------|--------|--------|------|
| 高 | 汇编系统化 | ⭐⭐ 零散 | 调试、性能分析能力提升 | 中 |
| 高 | 操作系统基础 | ⭐ 缺失 | 理解进程、线程、内存分页 | 高 |
| 中 | C++20 Concepts | ⭐ 缺失 | 现代模板编程能力 | 中 |
| 中 | 性能分析工具链 | ⭐⭐ 分散 | 实战优化能力 | 低 |
| 中 | 多线程与同步 | ⭐⭐ 涉及少 | UE关键性能话题 | 中 |
| 低 | Unity与C# | ⭐ 缺失 | 扩展游戏引擎广度 | 中 |

### 九、语言与沟通习惯

- **主语言**：中文（简体）
- **术语处理**：混用中英文（如"VTable"、"CDO"、"vtable"保留英文，"虚函数表"、"类默认对象"用中文）
- **文档风格**：技术文档式，结构化强（问题→原理→方案三段论）
- **代码示例**：必须包含详细注释，解释内存行为和执行流程
- **可视化**：偏好内存布局图、汇编对比、流程图辅助理解

---

## 使用建议

### 场景一：日常技术问答
复制**版本一（简洁版）**到对话开头，让AI快速了解你的技术水平和偏好。

### 场景二：深度技术讨论
使用**版本二（详细版）**，获得更精准的技术深度匹配。

### 场景三：技术学习指导
结合"知识缺口与优先级"部分，让AI针对性地补充薄弱环节。

### 场景四：代码审查/架构设计
强调"学习方法论"部分，让AI按照你的思维模式（低层→上层，多维对比）进行分析。

---

## 更新日志

- 2026-01-13：初始版本创建，基于Obsidian知识库深度分析生成
- 待更新：随着学习进展，定期更新能力矩阵和知识盲区

---

## 相关文档

- [[CLAUDE.md]] - 项目级AI指导文档
- [[学习路径]] - 详细学习规划
- [[AI_Refactor_Rules]] - 笔记重构规则模板
