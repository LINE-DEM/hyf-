问题1：整体流程是否是延迟加载+显式链接方案 
问题2：详细讲解P/Invoke 和如何触发原生 DLL 加载

待解决：延迟加载 都没加载dll 那么导入 

这两个问题问得非常精准，让我们深入剖析。

## 问题1：是延迟加载还是显式链接？

答案是：**两者都是，但又不完全是**。P/Invoke 是一种独特的混合机制，我称之为"延迟触发的自动显式链接"。让我用你笔记中的三种 DLL 引用方式来对比分析：

```
═══════════════════════════════════════════════════════════════════════════════
三种 Win32 DLL 加载方式 vs P/Invoke 的对比
═══════════════════════════════════════════════════════════════════════════════

                    编译时需要      加载时机           开发者是否手动
                    导入库(.lib)                      调用LoadLibrary
───────────────────────────────────────────────────────────────────────────────
隐式链接              需要         程序启动时            不需要
显式链接              不需要       代码中手动控制         需要
延迟加载              需要         首次调用函数时         不需要
───────────────────────────────────────────────────────────────────────────────
P/Invoke             不需要        首次调用函数时         不需要（CLR代劳）
───────────────────────────────────────────────────────────────────────────────

P/Invoke 的独特之处：
├─ 像延迟加载：加载时机是首次调用时，不是程序启动时
├─ 像显式链接：不需要导入库，运行时动态解析符号
├─ 但又自动化：开发者不写 LoadLibrary/GetProcAddress，CLR 自动处理
└─ 本质上是：CLR 在幕后执行显式链接，时机是延迟的
```

更精确地说，P/Invoke 的行为可以这样理解：**它在源代码层面看起来像隐式链接（你直接调用函数），在加载时机上像延迟加载（首次调用时才加载），但在底层实现上是显式链接（LoadLibrary + GetProcAddress）**。

## 问题2：P/Invoke 的完整机制

现在让我从编译到运行，完整地展示 P/Invoke 的每一个阶段。

```
═══════════════════════════════════════════════════════════════════════════════
阶段 0: P/Invoke 声明（源代码层面）
═══════════════════════════════════════════════════════════════════════════════

你在 C# 代码中写下这样的声明：

┌─────────────────────────────────────────────────────────────────────────────┐
│ // 这是一个 P/Invoke 声明                                                    │
│ [DllImport("onnxruntime",                    // DLL 名称（不需要 .dll 后缀） │
│            EntryPoint = "OrtGetApiBase",     // 导出函数名                   │
│            CallingConvention = CallingConvention.Cdecl)]  // 调用约定        │
│ private static extern IntPtr OrtGetApiBase();                               │
│                                                                             │
│ // 这个方法没有方法体！只有声明，没有实现                                      │
│ // extern 关键字告诉编译器：实现在别处（原生代码中）                           │
└─────────────────────────────────────────────────────────────────────────────┘

关键概念对比（用你熟悉的 C++ 术语）：

C++ 隐式链接：
    #pragma comment(lib, "onnxruntime.lib")    // 需要导入库
    __declspec(dllimport) void* OrtGetApiBase();

C++ 显式链接：
    HMODULE h = LoadLibrary("onnxruntime.dll");
    auto func = (void*(*)())GetProcAddress(h, "OrtGetApiBase");

C# P/Invoke：
    [DllImport("onnxruntime")]
    static extern IntPtr OrtGetApiBase();
    // 看起来像隐式链接的语法，但行为像自动化的显式链接


═══════════════════════════════════════════════════════════════════════════════
阶段 1: C# 编译器处理 P/Invoke 声明
═══════════════════════════════════════════════════════════════════════════════

C# 编译器 (csc.exe / Roslyn) 处理这段代码：

源代码：
    [DllImport("onnxruntime", EntryPoint = "OrtGetApiBase")]
    private static extern IntPtr OrtGetApiBase();
    ↓
编译器不生成任何机器码！
    ↓
编译器只在 IL 元数据中记录信息：

┌─────────────────────────────────────────────────────────────────────────────┐
│ 生成的 IL 元数据（可用 ildasm.exe 或 ILSpy 查看）                             │
│                                                                             │
│ .method private hidebysig static pinvokeimpl("onnxruntime" as "OrtGetApiBase"│
│         winapi)                                                              │
│     native int OrtGetApiBase() cil managed preservesig                      │
│ {                                                                           │
│     // 注意：这里没有任何 IL 指令！方法体是空的！                               │
│ }                                                                           │
│                                                                             │
│ 元数据表中记录：                                                              │
│ ┌───────────────────────────────────────────────────────────────┐           │
│ │ ImplMap 表（P/Invoke 实现映射）：                               │           │
│ │   Method: OrtGetApiBase                                       │           │
│ │   ModuleRef: "onnxruntime"  ← DLL 名称                        │           │
│ │   ImportName: "OrtGetApiBase"  ← 导出函数名                    │           │
│ │   Flags: CallingConvention=Cdecl, CharSet=Auto, ...           │           │
│ └───────────────────────────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────────────────────────┘

对比 C++ 编译：
    C++ 编译器会在 .obj 中留下"未解析符号"，由链接器处理
    C# 编译器只是把 P/Invoke 信息"登记"在元数据中，不做任何解析

此时状态：
    ✓ DLL 名称和函数名记录在元数据中
    ✗ 没有任何实际的函数地址
    ✗ 没有验证 DLL 是否存在
    ✗ 没有验证函数是否存在


═══════════════════════════════════════════════════════════════════════════════
阶段 2: 程序集加载（程序启动时）
═══════════════════════════════════════════════════════════════════════════════

Unity/Mono 启动，加载 Microsoft.ML.OnnxRuntime.dll：

CLR/Mono 加载程序集
    ↓
读取 PE 头和 .NET 元数据
    ↓
解析类型定义、方法签名...
    ↓
发现 NativeMethods 类有 P/Invoke 方法
    ↓
【关键】此时 CLR 不会加载 onnxruntime.dll！
        只是知道"有这么一个 P/Invoke 声明"
    ↓
程序继续运行，等待 P/Invoke 方法被调用

这就是"延迟"的含义：
    DLL 的加载被推迟到真正需要的时候


═══════════════════════════════════════════════════════════════════════════════
阶段 3: 首次调用 P/Invoke 方法（触发点！）
═══════════════════════════════════════════════════════════════════════════════

你的代码执行到这里：

    // 某处调用了 P/Invoke 方法
    IntPtr apiBase = OrtGetApiBase();  // ← 首次调用！
    ↓
JIT 编译器被触发（Just-In-Time 编译）
    ↓
JIT 发现这是一个 P/Invoke 方法
    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ JIT 编译器的特殊处理（不同于普通方法）                                         │
│                                                                             │
│ 普通方法的 JIT 流程：                                                        │
│   IL 字节码 → 语义分析 → 优化 → 生成机器码                                    │
│                                                                             │
│ P/Invoke 方法的 JIT 流程：                                                   │
│   1. 读取元数据中的 ImplMap 信息                                              │
│   2. 生成"存根代码"(Stub)，用于：                                             │
│      - 加载 DLL                                                             │
│      - 获取函数地址                                                          │
│      - 参数类型转换（Marshalling）                                           │
│      - 调用约定适配                                                          │
│      - 错误处理                                                              │
│   3. 这个存根代码就是 P/Invoke 方法的"实现"                                   │
└─────────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
阶段 4: P/Invoke 存根代码执行（核心机制）
═══════════════════════════════════════════════════════════════════════════════

JIT 生成的存根代码（伪代码，展示实际发生的事情）：

┌─────────────────────────────────────────────────────────────────────────────┐
│ // 这是 CLR 内部为 OrtGetApiBase 生成的存根代码（简化版）                      │
│                                                                             │
│ IntPtr OrtGetApiBase_Stub()                                                 │
│ {                                                                           │
│     // ═══════════════════════════════════════════════════════════════════  │
│     // 步骤 1: 查找或加载 DLL                                                 │
│     // ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│     // 检查 DLL 是否已经加载过                                                │
│     static IntPtr cachedModuleHandle = IntPtr.Zero;                         │
│     static IntPtr cachedFuncAddress = IntPtr.Zero;                          │
│                                                                             │
│     if (cachedModuleHandle == IntPtr.Zero)                                  │
│     {                                                                       │
│         // 首次调用，需要加载 DLL                                             │
│         // 这里调用的就是你熟悉的 Win32 API！                                  │
│         cachedModuleHandle = LoadLibrary("onnxruntime.dll");                │
│                                                                             │
│         if (cachedModuleHandle == IntPtr.Zero)                              │
│         {                                                                   │
│             // 加载失败                                                      │
│             throw new DllNotFoundException("onnxruntime.dll");              │
│         }                                                                   │
│                                                                             │
│     // ═══════════════════════════════════════════════════════════════════  │
│     // 步骤 2: 获取函数入口点                                                 │
│     // ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│         cachedFuncAddress = GetProcAddress(                                 │
│             cachedModuleHandle,                                             │
│             "OrtGetApiBase"    // 从元数据的 EntryPoint 获取                 │
│         );                                                                  │
│                                                                             │
│         if (cachedFuncAddress == IntPtr.Zero)                               │
│         {                                                                   │
│             // ← ← ← 你的错误就发生在这里！                                   │
│             throw new EntryPointNotFoundException("OrtGetApiBase");         │
│         }                                                                   │
│     }                                                                       │
│                                                                             │
│     // ═══════════════════════════════════════════════════════════════════  │
│     // 步骤 3: 准备调用（Marshalling）                                        │
│     // ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│     // 对于这个简单函数，没有参数需要转换                                       │
│     // 但如果有 string 参数，这里会进行 Unicode → ANSI 转换等                  │
│                                                                             │
│     // ═══════════════════════════════════════════════════════════════════  │
│     // 步骤 4: 切换到原生代码执行                                              │
│     // ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│     // 保存托管状态（GC 安全点等）                                             │
│     SuppressGCTransition();                                                 │
│                                                                             │
│     // 使用 cdecl 调用约定调用原生函数                                         │
│     // 这就是一个普通的函数指针调用！                                          │
│     typedef IntPtr (*NativeFunc)();                                         │
│     NativeFunc nativeCall = (NativeFunc)cachedFuncAddress;                  │
│     IntPtr result = nativeCall();                                           │
│                                                                             │
│     // 恢复托管状态                                                          │
│     RestoreGCState();                                                       │
│                                                                             │
│     // ═══════════════════════════════════════════════════════════════════  │
│     // 步骤 5: 处理返回值                                                     │
│     // ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│     return result;  // IntPtr 不需要转换                                     │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

## DLL 搜索顺序的细节

当 CLR 执行 `LoadLibrary("onnxruntime.dll")` 时，搜索顺序如下：

```
═══════════════════════════════════════════════════════════════════════════════
CLR/Mono 的 DLL 搜索顺序（与纯 Win32 略有不同）
═══════════════════════════════════════════════════════════════════════════════

1. 应用程序目录
   ├─ 标准 .NET：exe 所在目录
   └─ Unity：
        ├─ 编辑器模式：Unity Editor 安装目录
        └─ 构建后：构建输出目录（包含 exe 的目录）

2. 程序集所在目录
   ├─ Microsoft.ML.OnnxRuntime.dll 所在的目录
   └─ Unity 中：Assets/Plugins 或其子目录

3. 系统目录
   └─ C:\Windows\System32

4. Windows 目录
   └─ C:\Windows

5. 当前工作目录
   ├─ 可能不是你想的那个！
   └─ Unity 编辑器模式下，通常是 Unity 安装目录

6. PATH 环境变量中的目录
   └─ 按顺序搜索每个目录

⚠️ Unity 特殊情况：
   Unity 会优先检查 Assets/Plugins 目录及其平台子目录：
   ├─ Assets/Plugins/
   ├─ Assets/Plugins/x86_64/
   └─ Assets/Plugins/Windows/
   
   这是 Unity 自己的逻辑，在调用 LoadLibrary 之前就处理了
```

## P/Invoke 的缓存机制

```
═══════════════════════════════════════════════════════════════════════════════
为什么只有首次调用时加载 DLL？
═══════════════════════════════════════════════════════════════════════════════

CLR/Mono 内部维护两级缓存：

第一级：DLL 句柄缓存（ModuleHandle Cache）
┌────────────────────────────────────────┐
│ DLL 名称         │ 句柄 (HMODULE)       │
├────────────────────────────────────────┤
│ "onnxruntime"    │ 0x00007FF8A1234567  │ ← 加载后缓存
│ "kernel32"       │ 0x00007FF8B0000000  │
│ "user32"         │ 0x00007FF8C0000000  │
└────────────────────────────────────────┘

第二级：函数地址缓存（每个 P/Invoke 方法一个槽位）
┌────────────────────────────────────────────────────────┐
│ 方法签名                     │ 函数地址                 │
├────────────────────────────────────────────────────────┤
│ OrtGetApiBase()              │ 0x00007FF8A1235000      │
│ OrtCreateSession(...)        │ 0x00007FF8A1236000      │
│ OrtRun(...)                  │ 0x00007FF8A1237000      │
└────────────────────────────────────────────────────────┘

调用流程：

第一次调用 OrtGetApiBase()：
    检查缓存 → 未命中
    LoadLibrary("onnxruntime.dll") → 获得句柄
    GetProcAddress(句柄, "OrtGetApiBase") → 获得地址
    缓存句柄和地址
    调用函数

第二次调用 OrtGetApiBase()：
    检查缓存 → 命中！
    直接使用缓存的地址调用函数
    （几乎零额外开销）
```

## 完整的时序图

让我把整个过程画成一个完整的时序图：

```
═══════════════════════════════════════════════════════════════════════════════
P/Invoke 完整执行时序
═══════════════════════════════════════════════════════════════════════════════

时间轴 ──────────────────────────────────────────────────────────────────────→

程序启动
    │
    ▼
[加载托管程序集]
    │ Microsoft.ML.OnnxRuntime.dll 加载到内存
    │ 元数据被解析，知道有 P/Invoke 方法存在
    │ 
    │ onnxruntime.dll 此时【不加载】
    │
    ▼
[程序运行中...]
    │
    │ ... 各种其他代码执行 ...
    │
    ▼
[你的代码]
    │ SileroVADManager.Start()
    │   └─ InitializeVAD()
    │       └─ new SessionOptions()
    │           └─ 触发 NativeMethods 静态构造函数
    │               └─ 调用 OrtGetApiBase()  ← 触发点！
    │
    ▼
[JIT 编译 P/Invoke 存根]
    │ 生成加载和调用的机器码
    │
    ▼
[执行存根代码]
    │
    ├──→ LoadLibrary("onnxruntime.dll")
    │         │
    │         ▼
    │    [Windows 加载器]
    │         │ 搜索 DLL 文件
    │         │ 映射到进程地址空间
    │         │ 执行 DllMain(DLL_PROCESS_ATTACH)
    │         │
    │         ▼
    │    返回模块句柄 (HMODULE)
    │
    ├──→ GetProcAddress(句柄, "OrtGetApiBase")
    │         │
    │         ▼
    │    [读取 DLL 导出表]
    │         │ 在导出表中查找 "OrtGetApiBase"
    │         │
    │         ▼
    │    💥 如果找不到：抛出 EntryPointNotFoundException
    │    ✓ 如果找到：返回函数地址
    │
    ├──→ 缓存句柄和地址
    │
    ├──→ 准备参数（Marshalling）
    │
    ├──→ 切换执行上下文（托管 → 原生）
    │
    ├──→ 通过函数指针调用原生代码
    │         │
    │         ▼
    │    [onnxruntime.dll 中的 OrtGetApiBase 函数执行]
    │         │
    │         ▼
    │    返回结果
    │
    ├──→ 切换执行上下文（原生 → 托管）
    │
    └──→ 转换返回值（Marshalling）
              │
              ▼
         返回给调用者
```

## 总结：P/Invoke 的本质

用你熟悉的编译链接术语来总结：

P/Invoke 本质上是 **CLR 自动执行的显式链接**，具有以下特征：

**编译期**：只记录元数据，不做任何符号解析。这与 C++ 的隐式链接完全不同——C++ 链接器会在编译期检查导入库中是否存在符号。

**运行期**：首次调用时才加载 DLL 并解析符号。这与 C++ 的延迟加载类似，但实现机制是显式链接（LoadLibrary + GetProcAddress）。

**缓存机制**：句柄和地址被缓存，后续调用直接使用缓存，性能接近直接函数指针调用。

你的错误发生在 `GetProcAddress` 返回 NULL 的那个点——DLL 被成功加载了，但导出表中没有请求的函数名。这说明托管包装器和原生 DLL 的版本不匹配，它们期望的 ABI 接口不一致。