# 编译与解释代码

## 编译

编译语言嵌入编译语言

![image-20251217104922162](C:\1.HYFStudy\res\image-20251217104922162.png)

编译语言的exe运行流程

![image-20251217105049555](C:\1.HYFStudy\res\exe运行流程.png)

内核在磁盘找到 加载到内存中 分配栈和堆  --> 成为了一个进程



## 解释

### 第一层理解：解释器的本质是什么

首先，我们需要理解一个关键事实：**解释器本身也是一个程序**。无论是Lua解释器还是Python解释器，它们本质上都是用C或C++写的普通程序。当你在命令行输入`lua test.lua`或`python test.py`时，你实际上是在运行一个名为lua或python的可执行文件，这个可执行文件读取你的脚本，解析它，然后执行它。



#### 运行流程

![image-20251217105402405](C:\1.HYFStudy\res\解释语言的运行流程.png)

把py脚本放到了py.exe    

运行前有一个翻译流程：在其中翻译为字节码而不是机器码

当Python解释器读取你的脚本文件时，它首先会进行**词法分析**，把你的代码文本切分成一个个的"词元"（token），比如识别出哪里是变量名、哪里是关键字、哪里是运算符。接下来是**语法分析**，把这些词元组织成一棵抽象语法树（AST），这棵树表达了代码的逻辑结构。然后，Python会把这棵语法树**编译成字节码**

这个过程在程序开始运行之前就完全做完了

让我用一个更具体的例子来说明。假设你有这样一行Python代码：

python

~~~python
result = a + b
```

经过编译后，它可能变成类似这样的字节码序列（简化表示）：
```
LOAD_NAME    a      # 把变量a的值压入栈
LOAD_NAME    b      # 把变量b的值压入栈  
BINARY_ADD         # 执行加法操作
STORE_NAME   result # 把结果存入变量result
~~~

当虚拟机执行`BINARY_ADD`这条字节码时，这些底层的加法操作都是编译好的机器码，执行速度非常快。



![epicpen_MY8OeZKo5Z](C:\1.HYFStudy\res\epicpen_MY8OeZKo5Z.gif)



#### 如何实现数据交换

<video src="C:\1.HYFStudy\res\epicpen_T1DVsblNkD.mp4" controls=""></video>



那么看完视频可以思考，当我们说"C++嵌入Lua"时，我们真正做的是什么呢？我们是把**解释器的核心代码**（也就是那些能够解析和执行脚本的代码）整合到我们自己的C++程序中。想象一下，你不是调用外部的lua.exe程序，而是把lua.exe的"内核"直接放进你的程序里，让它成为你程序的一部分。

上面视频生成的哈希表 就是lua源码 和c++代码交互的核心 因为你的c++程序可以通过嵌入的方式来直接控制lua源码 来交换数据。

todo：

那么tolua和xlua是什么呢？

如果我需要在unity中使用c#接入lua c#的编译是变为il 再在clr中编译吗 这样需要怎么嵌入c写的lua源码呢



## 第二层理解：嵌入的到底是什么形式

这是你问题的核心，也是最容易产生困惑的地方。让我分三种情况详细说明：

**嵌入静态库的方式（最常见）**

当你嵌入Lua时，通常你会得到或编译出一个静态库文件。在Windows上是`.lib`文件，在Linux上是`.a`文件。这个静态库包含了已经编译好的Lua解释器的机器码。你的C++项目在编译时，会把这个库的内容"合并"到你的最终可执行文件中。这就像是把两本书的内容合订成一本新书。

编译流程是这样的：首先，Lua的源代码（那些`.c`和`.h`文件）被编译成目标文件（`.o`或`.obj`），然后这些目标文件被打包成一个静态库。当你编译你的C++程序时，链接器会把你的代码和Lua静态库的代码合并在一起，生成最终的可执行文件。最终你得到的exe文件里，既包含你写的C++代码的机器码，也包含Lua解释器的机器码。

**嵌入动态库的方式**

另一种方式是使用动态库，在Windows上是`.dll`文件，在Linux上是`.so`文件。这种情况下，Lua解释器被编译成一个独立的动态库文件。你的程序在编译时只是记录"我需要lua这个库"，但并不把它的内容合并进来。当你的程序运行时，操作系统会加载这个dll文件到内存中，你的程序通过地址引用来调用Lua的功能。

这就像是你的书中写着"第三章请参阅另一本书的第五章"，两本书保持独立，但在阅读时需要同时翻阅两本。

**直接包含源码的方式**

还有一种不太常用但概念上最简单的方式：直接把Lua的源代码文件添加到你的项目中。这样，Lua的`.c`文件会和你的`.cpp`文件一起被编译。这种方式的好处是简单直接，不需要预先编译库文件，但缺点是编译时间较长，而且每个项目都要重新编译一次Lua。

## 第三层理解：完整的编译和链接流程

让我用一个具体的例子来说明整个流程。假设你要创建一个嵌入了Lua的C++游戏引擎：

**第一步：准备Lua库**

你首先需要获取Lua的实现。通常有两个选择：下载预编译的库文件，或者自己从源码编译。如果选择自己编译，你会下载Lua的源码包，里面大约有五十个`.c`文件和对应的`.h`文件。这些文件包含了虚拟机、垃圾回收器、标准库等所有组件。

你运行Lua提供的编译脚本或makefile，编译器会逐个编译这些源文件。每个`.c`文件被编译成一个`.o`目标文件，这些目标文件包含了机器码，但还不能直接运行，因为它们之间的相互引用还没有被解析。然后，归档工具（ar或lib.exe）会把所有这些目标文件打包成一个静态库文件，比如`liblua.a`或`lua54.lib`。

**第二步：编写你的C++代码**

你的C++代码需要包含Lua的头文件。这些头文件告诉编译器Lua提供了哪些函数、它们的参数类型是什么。特别重要的是，由于Lua是用C写的，你需要用`extern "C"`来告诉C++编译器按照C的方式处理这些函数名，避免C++的名称修饰机制造成链接错误。

你的代码可能是这样的：

```cpp
extern "C" {
    #include "lua.h"
    #include "lualib.h"
    #include "lauxlib.h"
}

// 你的游戏代码
int main() {
    lua_State* L = luaL_newstate();
    // ... 使用Lua
    lua_close(L);
    return 0;
}
```

**第三步：编译你的C++代码**

当你编译这个文件时，编译器看到了`luaL_newstate()`这个函数调用。但此时编译器并不知道这个函数的具体实现在哪里，它只是相信头文件的声明，生成一个"我需要调用这个函数"的占位符，把你的`.cpp`文件编译成`.o`目标文件。

**第四步：链接阶段**

这是最关键的一步。链接器的工作是把所有的目标文件组装成最终的可执行文件。它接收你的目标文件和Lua的静态库，然后做这样的事情：

首先，它在你的目标文件中发现了对`luaL_newstate`的引用。然后它在Lua静态库中搜索这个函数的实际实现。找到后，它会把这个函数的地址填入你代码中的占位符位置。

同时，如果`luaL_newstate`内部又调用了其他Lua函数，链接器会递归地解析所有这些依赖关系。最终，所有的函数调用都被正确地连接起来，形成一个完整的可执行文件。

这个可执行文件现在包含了完整的机器码，既有你写的游戏逻辑，也有Lua解释器的所有功能。当程序运行时，不再需要任何外部的Lua文件（如果是静态链接的话）。

## Python的特殊之处

Python的嵌入稍微复杂一些，主要原因在于Python的实现本身更加庞大和复杂。Python解释器不仅仅是一个简单的库，它包含了大量的标准模块、一个复杂的对象系统和一个全功能的垃圾回收器。

当你嵌入Python时，你通常需要链接到`libpython`这个库。在Windows上可能是`python39.lib`和`python39.dll`的组合，在Linux上是`libpython3.9.so`。Python更倾向于使用动态链接，因为它的标准库非常庞大，静态链接会使你的程序体积增加几十MB。

另一个重要区别是Python的初始化更复杂。Python需要知道它的标准库在哪里，需要设置模块搜索路径，需要初始化内置类型系统。这使得Python的嵌入代码通常比Lua更长一些：

```cpp
#include <Python.h>

int main() {
    // 初始化Python解释器
    Py_Initialize();
    
    // 执行Python代码
    PyRun_SimpleString("print('Hello from Python')");
    
    // 清理
    Py_Finalize();
    return 0;
}
```

编译这个程序时，你需要告诉编译器Python头文件的位置，告诉链接器Python库的位置。在Linux上命令可能是：

```bash
g++ -o myapp myapp.cpp -I/usr/include/python3.9 -L/usr/lib -lpython3.9
```

这条命令做了什么呢？`-I`告诉编译器去哪找头文件，`-L`告诉链接器去哪找库文件，`-lpython3.9`告诉链接器链接名为python3.9的库。链接器会自动添加前缀lib和后缀.so，实际寻找的是libpython3.9.so文件。

## 内存中的运行模型

当你的程序运行时，理解内存中发生了什么也很重要。以嵌入Lua为例：

你的程序启动后，所有的机器码（包括你的代码和Lua的代码）都被加载到内存的代码段。当你调用`luaL_newstate()`时，程序跳转到Lua代码的那部分内存执行。Lua创建一个新的虚拟机状态，分配内存来存储Lua的栈、全局变量表等数据结构。

当你用`luaL_dostring()`执行一段Lua脚本时，Lua解释器会解析这段字符串，将其编译成字节码（一种中间表示），然后虚拟机逐条执行这些字节码指令。这些字节码指令可能操作Lua的栈，调用内置函数，或者触发垃圾回收。

如果Lua脚本调用了一个你注册的C++函数，虚拟机会查找函数表，找到对应的C++函数指针，然后跳转回你的C++代码执行。执行完毕后，再跳转回Lua虚拟机继续执行后续的字节码。

整个过程中，你的程序始终只有一个进程，一份内存空间，所有的代码都在同一个地址空间中相互调用。这就是"嵌入"的真正含义：两种语言的运行时环境融合在一起，共享内存，相互协作。

## 两者的对比总结

Lua被设计为嵌入式语言，它的整个实现只有几万行C代码，编译出来的库文件很小（大约几百KB），而且API设计得非常清晰，专门为嵌入场景优化。这使得Lua成为游戏开发、嵌入式系统中最受欢迎的脚本语言。

Python则更像是一个完整的独立语言，它可以被嵌入，但这不是它的主要设计目标。Python的优势在于它有海量的第三方库和活跃的生态系统，如果你需要在C++程序中使用这些库的功能，嵌入Python就很有价值。但代价是更大的依赖和更复杂的部署。

理解了这些底层机制后，你就能明白为什么有些项目选择Lua，有些选择Python，以及在实际开发中如何根据需求做出正确的技术选择。