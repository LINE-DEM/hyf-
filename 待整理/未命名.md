我会为你精选几本能让你建立**从硬件到操作系统抽象层**完整心智模型的书籍。这些书的共同特点是不会停留在概念层面，而是会带你看到真实的代码、数据结构和硬件行为。

---

## 核心教材：Computer Systems: A Programmer's Perspective (CSAPP)

这本书是你整个 Phase 1 的主线，作者是 CMU 的 Randal Bryant 和 David O'Hallaron。它的独特之处在于**从程序员视角逆向解构计算机系统**，而不是从硬件工程师的角度正向构建。

### 为什么适合你

你已经有多年的 C++ 和 Unity 经验，这本书会帮你把过去积累的"经验性知识"转化为"可推理的模型"。比如你知道虚函数调用比普通函数慢，但这本书会让你在第三章看到具体慢在哪些 CPU 周期上（指令缓存未命中、分支预测失败、间接跳转）。你知道多线程需要加锁，但第十二章会让你理解为什么 spinlock 在某些场景下比 mutex 快十倍（避免内核态切换的成本）。

### 必读章节与阅读策略

**第七章 Linking（链接）**应该作为你的起点。这一章会解答你在 Unity 和 UE 之间迁移时遇到的困惑：为什么 UE 的模块系统要求你显式地用 `MODULENAME_API` 标记导出符号？为什么 DLL 的 delay load 能加快启动速度？你会看到链接器如何解析符号引用、如何处理重定位表（relocation entries），以及动态链接器（`ld.so` 或 `LoadLibrary`）在运行时如何修改指令中的地址。书中有一个实验让你用 `objdump -d` 查看可执行文件的 PLT（Procedure Linkage Table），这会让你理解为什么跨 DLL 的虚函数调用需要额外的间接跳转。

**第八章 Exceptional Control Flow（异常控制流）**是理解进程和信号机制的关键。这一章会从硬件中断（interrupt）讲到系统调用（syscall）再到信号（signal），建立起"从硅片到用户代码"的完整调用链。你会看到当你在调试器里按下暂停按钮时，OS 如何向进程发送 SIGSTOP 信号，以及进程的信号处理函数如何在内核态返回用户态时被调用（通过修改栈帧的返回地址）。书中有一个练习让你实现一个简单的 shell，通过 fork、execve、waitpid 这些系统调用来理解进程的创建和回收，这会帮你理解为什么 UE 的 Editor 能在不重启的情况下重新编译代码（它用子进程运行编译器，然后用 `LoadLibrary` 热加载新的 DLL）。

**第九章 Virtual Memory（虚拟内存）**是你必须反复阅读的一章。这一章会让你理解为什么 64 位程序能使用 TB 级别的地址空间，但物理内存只有几十 GB——答案在于页表（page table）和按需分页（demand paging）。你会看到 MMU（Memory Management Unit）如何用 TLB（Translation Lookaside Buffer）缓存虚拟地址到物理地址的映射，以及为什么访问不连续的内存会导致 TLB 抖动（thrashing）。书中有一个实验让你写一个矩阵转置函数，通过改变访问顺序来优化 cache miss 率，这个思维会直接应用到 UE 的数据布局设计上（比如为什么 Transform 数组要按 SoA 而不是 AoS 存储）。这一章还会解释写时复制（Copy-on-Write）机制，让你理解为什么 fork 一个占用 10GB 内存的进程只需要几毫秒。

**第十二章 Concurrent Programming（并发编程）**会用三种并发模型（进程、I/O 多路复用、线程）的对比来让你理解它们的权衡。这一章的精华在于用具体的性能数据告诉你：创建一个线程需要多少微秒（约 20μs），上下文切换需要多少时钟周期（约 1000-1500 cycles），以及为什么无锁队列在某些场景下能比互斥锁快 100 倍。书中会让你实现一个并发服务器，通过 Valgrind 的 Helgrind 工具检测数据竞争，这会让你对 UE 的 `TSAN`（Thread Sanitizer）有更深的理解。

### 这本书的局限性

这本书的主要缺点是它基于 x86-64 和 Linux 系统，如果你的目标平台是 ARM 或 Windows，某些细节会有差异。比如 Windows 的线程本地存储（TLS）使用 FS 段寄存器而不是 GS，Windows 的异常处理用 SEH（Structured Exception Handling）而不是信号。另外，这本书的并发章节写于 2015 年，没有涵盖 C++11 之后的内存模型（memory_order），你需要用其他书籍补充这部分知识。

### 配套实验指南

这本书配有一套完整的实验（CMU 15-213 课程的 labs），你可以在官网下载。我特别推荐你做 **Malloc Lab**，这个实验会让你从零实现一个内存分配器，支持 malloc、free、realloc。你会遇到的挑战包括：如何设计空闲块链表（free list）来减少碎片、如何用边界标记（boundary tags）实现 O(1) 的块合并、如何在吞吐量和利用率之间做权衡。当你完成这个实验后，再去看 UE 的 `FMallocBinned2` 源码，你会立刻理解它为什么用 size class 和线程缓存的设计。

---

## 深度补充：Operating Systems: Three Easy Pieces (OSTEP)

这本书是威斯康星大学的 Remzi Arpaci-Dusseau 和 Andrea Arpaci-Dusseau 夫妇写的，完全免费在线阅读。它的风格是"对话式教学"，每一章都从一个具体问题出发（比如"如何让多个进程共享 CPU？"），然后逐步引入解决方案。

### 为什么作为补充

OSTEP 和 CSAPP 的互补性在于：CSAPP 侧重"程序员如何利用 OS 提供的抽象"，而 OSTEP 侧重"OS 内核如何实现这些抽象"。当你读完 CSAPP 第八章关于进程的内容，可能会好奇：OS 的调度器（scheduler）到底是怎么决定下一个运行哪个进程的？OSTEP 的**第七到十章（CPU Scheduling）**会给你答案，从最简单的 FIFO 调度讲到多级反馈队列（MLFQ），再到完全公平调度（CFS）。你会看到 Linux 的 CFS 如何用红黑树维护虚拟运行时间（vruntime），以及为什么这个设计能在 O(log n) 时间内选出下一个任务。

### 重点章节推荐

**第十三到十六章（Address Spaces）**会从"如何让每个进程以为自己独占内存"这个问题出发，带你看分段（segmentation）、分页（paging）、多级页表（multi-level page table）的演化历程。这部分的价值在于让你理解为什么现代 OS 放弃了分段（除了 x86 的兼容模式），以及为什么 4KB 的页面大小是一个精心设计的权衡（更大的页面会导致内部碎片，更小的页面会让页表占用过多内存）。书中有一个模拟器（paging-linear-translate.py）让你手动计算虚拟地址到物理地址的转换，这会让你对页表的层级结构有直观感受。

**第二十六到三十章（Concurrency）**是这本书的精华。它不仅讲互斥锁（mutex）和条件变量（condition variable）的使用，还会深入到它们的实现细节。你会看到一个自旋锁如何用 test-and-set 指令（x86 的 `XCHG` 或 ARM 的 `LDREX/STREX`）实现原子性，以及为什么简单的自旋会导致 cache thrashing（因为所有等待的核心都在反复读写同一个 cache line）。书中会介绍 ticket lock 和 MCS lock 这些改进方案，让你理解为什么 Linux 内核用 qspinlock。这些知识会直接应用到你阅读 UE 的 `FWindowsCriticalSection` 或 `FPThreadsCriticalSection` 源码时。

### 局限性与阅读建议

这本书的缺点是它偏向理论和历史演进，缺少像 CSAPP 那样的实战项目。我建议你把它当作"睡前读物"——当你在 CSAPP 的实验中遇到困惑时，切换到 OSTEP 的相关章节寻找更高层次的解释。比如你在做 Shell Lab 时不理解为什么需要 `sigprocmask` 来阻塞信号，OSTEP 的第三十三章会告诉你这是为了避免竞态条件（race condition）：如果子进程在父进程来得及将它加入 job list 之前就退出了，父进程可能会收到一个无法处理的 SIGCHLD 信号。

---

## 内存管理专精：Understanding the Linux Virtual Memory Manager

这本书由 Mel Gorman 撰写，是 Linux 内核内存管理子系统的完整剖析。它不适合作为入门读物，但如果你想理解"内存分配器"这个 UE 中的核心组件，这本书会给你无与伦比的深度。

### 为什么推荐给你

你在 Profile 里提到想理解"内存级"的细节，这本书会让你看到 OS 如何管理物理内存的每一个字节。它会解释 Linux 的伙伴系统（Buddy System）如何用位图（bitmap）和链表管理不同大小的空闲块，以及 Slab 分配器如何为内核对象提供对象池。当你理解了这些机制，再去看 UE 的 `FMallocBinned2`，你会发现它本质上是用户态的 Slab 分配器——都是用预分配的内存块（pool）和 size class 来减少碎片和锁竞争。

### 关键章节

**第六章（Physical Page Allocation）**会让你理解伙伴系统的实现细节。这个算法的巧妙之处在于用二进制表示来快速找到"伙伴块"（buddy block）：如果你释放一个 0x1000 地址的 4KB 块，它的伙伴是 0x1000 XOR 0x1000 = 0x2000。书中会展示内核如何用位图标记哪些块是空闲的，以及如何在 O(1) 时间内完成块的分裂（split）和合并（coalesce）。

**第八章（Slab Allocator）**会让你理解为什么频繁分配小对象（比如 `kmalloc(64)）不会导致系统调用。Slab 的核心思想是为每种大小的对象维护一个缓存（cache），每个缓存包含多个 slab（一个 slab 通常是几个连续的页面），每个 slab 被切分成多个对象。当你调用` kmalloc` 时，分配器只需要从对应的 cache 中取一个空闲对象，这是 O(1) 操作。书中会解释 slab coloring 技术如何通过偏移对象的起始地址来减少 cache line 冲突。

### 如何阅读

这本书有 700 多页，不需要从头读到尾。我建议你采用"问题驱动"的阅读方式：当你在实现自己的内存分配器时遇到具体问题（比如"如何快速找到大小为 N 的空闲块？"），就跳到对应的章节查找答案。你可以把它当作参考手册，而不是教科书。

---

## 并发原语深度：The Art of Multiprocessor Programming

这本书由 Maurice Herlihy 和 Nir Shavit 撰写，专注于并发数据结构和算法。它会从理论（linearizability、wait-freedom）讲到实践（如何用 CAS 实现无锁队列），是你理解 UE 的 `TLockFreePointerListUnordered` 的必备背景。

### 核心价值

这本书会让你理解"无锁编程"并不是简单地去掉 lock，而是用原子操作和内存屏障（memory barrier）来构建更细粒度的同步原语。**第七章（Spin Locks and Contention）**会解释为什么简单的 test-and-set 自旋锁在高竞争场景下性能很差：所有等待的线程都在同一个变量上自旋，导致 cache line 在多个核心之间反复传递（这被称为 cache line bouncing）。书中会介绍 test-and-test-and-set、backoff、queue-based lock（MCS lock）等改进方案，每种方案都配有性能测试数据。

**第十到十一章（Concurrent Objects 和 Queues）**会教你如何设计线程安全的数据结构。你会看到一个无锁队列的完整实现（Michael-Scott queue），理解为什么需要用 CAS（Compare-And-Swap）的循环来处理竞争，以及 ABA 问题（一个指针从 A 变成 B 再变回 A，CAS 无法检测到中间的变化）如何用版本号解决。这些技术会直接应用到你阅读 UE 的 `TCircularQueue` 或 Unity Job System 的 `NativeQueue` 源码时。

### 阅读建议与局限

这本书的难度较高，假设你已经熟悉基本的并发概念（mutex、semaphore）。我建议你先读完 CSAPP 第十二章和 OSTEP 的并发部分，再来读这本书。另外，这本书用 Java 作为示例语言，你需要在脑海中把 `synchronized` 映射到 C++ 的 `std::mutex`，把 `volatile` 映射到 `std::atomic`（注意 Java 的 volatile 语义比 C++ 的 volatile 强，它保证了 happen-before 关系）。

---

## 阅读顺序与时间分配建议

我建议你按照这样的顺序交替阅读，每天投入两到三小时：

第一周，你应该聚焦在 CSAPP 的第七章和第八章。这两章会建立你对"程序如何加载和运行"的基础理解。同时配合 OSTEP 的第四到六章（进程的抽象），从两个视角理解同一个概念。你应该在虚拟机或 WSL 环境里完成 CSAPP 的 Shell Lab，通过亲手实现一个 shell 来加深对进程和信号的理解。

第二周，转向内存管理。先读 CSAPP 第九章前半部分（虚拟内存机制），然后读 OSTEP 第十三到十六章（地址空间和分页）。这时候你可以翻阅 Gorman 的书的第一到三章（Linux 内存管理概述），看看理论如何在真实系统中实现。完成 CSAPP 的 Malloc Lab 是这一阶段的里程碑——当你的分配器通过所有测试用例时，你会对内存管理有质的飞跃。

第三周，专注于并发。读 CSAPP 第十二章和 OSTEP 第二十六到三十章，理解锁、条件变量、信号量的使用场景。然后开始读 Herlihy 的书的前七章，理解无锁编程的理论基础。你应该实现一个无锁的 SPSC（Single-Producer Single-Consumer）队列，用 `std::atomic` 和 memory order 来保证正确性，然后用性能测试对比它和基于 mutex 的版本。

当你完成这三周的学习后，你会发现自己已经能够理解 UE 源码中的大部分"奇怪设计"。比如你会理解为什么 `FMallocBinned2` 的每个线程缓存（Thread Cache）要对齐到 64 字节（避免 false sharing），为什么 `FEvent` 的实现在 Windows 上用 `WaitForSingleObject` 而在 Linux 上用 futex（因为 futex 是更轻量级的同步原语，它在无竞争时完全在用户态完成）。

你准备好开始了吗？我建议你现在就去下载 CSAPP 的配套实验环境，先运行一遍书中的示例代码，感受一下"从汇编到 C 语言"的视角转换。如果你在阅读过程中遇到任何困惑，随时告诉我具体是哪个概念不清楚，我可以用更多的例子和类比来帮你打通。