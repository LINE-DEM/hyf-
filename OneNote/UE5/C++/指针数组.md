![Exported image](pic/Exported%20image%2020260113112510-0.png)     

方便书写 直接ptr 1 就是去取下一个地址偏移4的数据

![Exported image](pic/Exported%20image%2020260113112511-1.png)   
需要注意的是  
1.在win中 &y\>&x 但是在mac中反过来了  
2.如果不打印一下地址 有可能编译器直接就不会给他们分配内存上的地址 直接在寄存器中算完了
 
所以 引出了下面的概念

![Exported image](pic/Exported%20image%2020260113112512-2.png)

这样才有意义 比如数组 字符串

![Exported image](pic/Exported%20image%2020260113112516-3.png)

其实数组到指针的时候做了隐式转换

![Exported image](pic/Exported%20image%2020260113112517-4.png)   
数组的类型其实是int[5] 代表整个内存

![Exported image](pic/Exported%20image%2020260113112519-5.png)   ![Exported image](pic/Exported%20image%2020260113112521-6.png)

下面这个是指针数组 元素为int* 长度为5的指针数组  
我们需要的是 指向元素为int长度为5的int数组的指针

![Exported image](pic/Exported%20image%2020260113112522-7.png)  
![Exported image](pic/Exported%20image%2020260113112524-8.png)  

取个别名 规避c++的垃圾书写

![Exported image](pic/Exported%20image%2020260113112525-9.png)        

一般情况：

![Exported image](pic/Exported%20image%2020260113112529-10.png)

写为数组形式（但他还是指针 还是需要变量N告诉大小）

![Exported image](pic/Exported%20image%2020260113112530-11.png)  

直接传 数组的指针

![Exported image](pic/Exported%20image%2020260113112531-12.png)  

把指针改为引用写法 用起来不需要每次写*解引用

![Exported image](pic/Exported%20image%2020260113112532-13.png)  

如果觉得写死数组大小不方便 可以使用Auto 自动推断出类型 当前类型为元素int长度为6 的数组的指针 (C++20中才有 )

![Exported image](pic/Exported%20image%2020260113112533-14.png)     

二维数组：  
1.我们知道 数组的名字 其实是指向第一个数据的指针  
2.在二维数组中 第一个元素 其实是数组指针
 ![Exported image](pic/Exported%20image%2020260113112534-15.png)

两种方式来遍历