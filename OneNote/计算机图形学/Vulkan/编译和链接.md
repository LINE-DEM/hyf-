**编译**

![Exported image](Exported%20image%2020260112170133-0.png)   ![Exported image](Exported%20image%2020260112170136-1.png)

有一个main 用了math的函数  
那么编译的时候 这两个都要用gcc -c 编译一下  
然后输出了两个.o 也就是目标文件（ObjectFile） 但是还不能执行 因为里面的add方法 甚至printf方法 目前没链接的时候 只是一句声明 编译器 不知道他在内存的哪个区域  
所以编译器在生成.o的时候 只能先把Add函数的跳转地址设为0

![Exported image](Exported%20image%2020260112170137-2.png)

输出一下文件格式 这是一个二进制的文件 格式是ELF windows下用的格式是PE 这都是对二进制代码的一种封装 十分相似
 
==ELF====结构==  
1.可以在**ELF Header**中找到一些信息 （支持的操作系统 机器类型等）

![Exported image](Exported%20image%2020260112170139-3.png)  

2.**Section****区**

![Exported image](Exported%20image%2020260112170142-4.png)  

**.text** **是写好的代码**  
**.data** **是数据区** **（初始化的全局变量** **局部静态变量等）**
       
**链接**  
**重定位表**

![Exported image](Exported%20image%2020260112170149-5.png)  
![Exported image](Exported%20image%2020260112170151-6.png)  

**根据这个重定位表** **填充****.o****文件之前空缺的跳转地址** **和全局变量**
       
**因为手动编译链接太繁琐**  
**makeflie****来管理依赖（安卓就是用这个）**

![Exported image](Exported%20image%2020260112170152-7.png)  

**先运行****make** **来生成依赖树**

![Exported image](Exported%20image%2020260112170154-8.png)

**如果修改了****main.c**  
**再重新****make****一下** **他只会重新生成影响的节点**